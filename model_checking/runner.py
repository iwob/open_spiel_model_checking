import os
import subprocess
from collections import defaultdict
import re
import time
from pathlib import Path

from absl import app
from absl import flags

flags.DEFINE_string("results_dir", None, required=True, help="Directory containing all results generated by mcts.py, each of which represents a certain submodel.")
flags.DEFINE_string("mcmas_path", None, required=False, help="Path to the MCMAS executable.")
FLAGS = flags.FLAGS


def parse_output(output):
    lines = output.split('\n')
    
    verification_results = {}
    execution_time = None
    # TODO: Parsing probably should be done by a GameUtilities, to handle all the pecularities of particular problems
    for line in lines:
        if "Formula number 1:" in line:
            verification_results["Formula 1"] = "TRUE" if "is TRUE" in line else "FALSE"
        elif "Formula number 2:" in line:
            verification_results["Formula 2"] = "TRUE" if "is TRUE" in line else "FALSE"
        elif "execution time =" in line:
            execution_time = float(line.split('=')[-1].strip())
    
    return verification_results, execution_time


def parse_logs_correctly_fixed_v2(logs):
    game_tree = {}
    # TODO: Take moves from the "-- History: " instead of file name
    pattern_moves = r"output_(.*)\.txt"
    # TODO: Handle variable number of formulas
    pattern_results = r"Formula 1: (\w+)\n\s+Formula 2: (\w+)"
    
    for log in logs:
        moves_match = re.search(pattern_moves, log)
        results_match = re.search(pattern_results, log)
        
        if moves_match and results_match:
            # Split the moves correctly
            # TODO: Use GameUtilities to properly parse a moves text description into a sequence of moves
            moves = re.findall(r'[xo]\(\d,\d\)', moves_match.group(1))
            result_x = results_match.group(1) == "TRUE"
            result_o = results_match.group(2) == "TRUE"
            
            # Traverse through the tree and build nodes using full moves
            node = game_tree
            for move in moves:
                if move not in node:
                    node[move] = {}
                node = node[move]
            # Store the results at the leaf node
            node['result'] = (result_x, result_o)

    return game_tree

def minimax(node, is_maximizing_player):
    if 'result' in node:
        # If it's a leaf node, return the result for player X
        return 1 if node['result'][0] else -1 if node['result'][1] else 0
    
    if is_maximizing_player:
        best_value = -float('inf')
        for key in node:
            value = minimax(node[key], False)
            best_value = max(best_value, value)
        return best_value
    else:
        best_value = float('inf')
        for key in node:
            value = minimax(node[key], True)
            best_value = min(best_value, value)
        return best_value

def generate_latex_table(logs):
    # LaTeX table header
    table = "\\begin{tabular}{|c|c|c|}\n\\hline\n"
    table += "Moves sequence & Victory X & Victory O \\\\\n\\hline\n"

    for log in logs:
        # Using regex to extract filename and results of the formulas
        file_name_match = re.search(r"File: (.+)\.txt", log)
        formula_1_match = re.search(r"Formula 1: (TRUE|FALSE)", log)
        formula_2_match = re.search(r"Formula 2: (TRUE|FALSE)", log)
        
        if file_name_match and formula_1_match and formula_2_match:
            # Sequence of moves is a part of the filename between 'output_' and '.txt'
            sequence = file_name_match.group(1).replace("output_", "")
            win_x = "YES" if formula_1_match.group(1) == "TRUE" else "NO"
            win_o = "YES" if formula_2_match.group(1) == "TRUE" else "NO"
            
            # Adding row to the table
            table += f"{sequence} & {win_x} & {win_o} \\\\\n\\hline\n"

    table += "\\end{tabular}"
    
    return table


def MCSA():
    """MCSA = Model Checking by Submodel Aggregation."""
    pass


def run_MCMAS(file_path, mcmas_path):
    result = subprocess.run([mcmas_path, file_path], capture_output=True, text=True)
    output = result.stdout  # Capturing standard output
    print(output)
    return output


def verify_submodels_MCMAS(folder_path, mcmas_path):
    """Verifies all submodels in a given folder using MCMAS."""
    results = []
    # Iterating over all files in the directory
    for file_name in os.listdir(folder_path):
        print("(*) Processing file:", file_name)
        file_path = os.path.join(folder_path, file_name)

        if os.path.isfile(file_path):
            output = run_MCMAS(file_path, mcmas_path)
            verification_results, execution_time = parse_output(output)

            results.append({
                "file_name": file_name,
                "verification_results": verification_results,
                "execution_time": execution_time
            })

    return results


def process_experiment_with_multiple_runs(root_dir, solver_path):
    """Handles collection and interpretation of results by invoking MCSA for each run conducted in a given experiment,
     where by an experiment we mean a particular model checking problem.

    :param root_dir: A path to the root directory containing directories (run-directories) for separate experiment runs.
     Each run-directory contains several submodel .ispl files.
    :return:
    """
    final_outputs = ""
    for folder_path in root_dir:
        start = time.time()
        debug = True
        # folder_path = f"/home/iwob/mcts_start__5_5_4{i}/"  # Zmienna wskazujÄ…ca na folder z plikami
        if not debug:
            results = verify_submodels_MCMAS(folder_path, solver_path)
        logs = []
        if debug:
            files = ["output_x(2,2),o(1,2).txt", "output_x(2,2),o(3,3),x(0,0).txt", "output_x(2,2),o(3,3),x(1,1).txt"]
            f1 = ["FALSE", "TRUE", "FALSE"]
            f2 = ["TRUE", "FALSE", "FALSE"]
            exs = [0, 0]
            for file, f1_, f2_, e in zip(files, f1, f2, exs):
                log_entry = (
                    f"File: {file}\n"
                    f"  Formula 1: {f1_}\n"
                    f"  Formula 2: {f2_}\n"
                    f"  Execution time: {e} s"
                )
                logs.append(log_entry)
        else:
            for result in results:
                log_entry = (
                    f"File: {result['file_name']}\n"
                    f"  Formula 1: {result['verification_results'].get('Formula 1')}\n"
                    f"  Formula 2: {result['verification_results'].get('Formula 2')}\n"
                    f"  Execution time: {result['execution_time']} s"
                )
                logs.append(log_entry)

        # Build the game tree with parsed moves
        game_tree_corrected_fixed_v2 = parse_logs_correctly_fixed_v2(logs)

        # Apply minimax to the root of the corrected and fixed game tree
        result_for_x_corrected_fixed_v2 = minimax(game_tree_corrected_fixed_v2, True)
        # print(game_tree_corrected_fixed_v2, result_for_x_corrected_fixed_v2)
        end = time.time()
        final_outputs += f"results ({folder_path}): {end - start} {result_for_x_corrected_fixed_v2}\n"
        print(f"results ({folder_path}):", end - start, result_for_x_corrected_fixed_v2)
        # print(generate_latex_table(logs))

    print(final_outputs)


def main(argv):
    if FLAGS.mcmas_path is None:
        mcmas_path = "/home/iwob/Programs/MCMAS/mcmas-linux64-1.3.0"

    run_result_dirs = []
    for f in Path(FLAGS.results_dir).iterdir():
        print(f)
        if f.is_dir():
            run_result_dirs.append(f)

    process_experiment_with_multiple_runs(run_result_dirs, solver_path=mcmas_path)



if __name__ == "__main__":
    app.run(main)
